---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ku-pmm-algo-usdt-sa
  namespace: hummingbot
  labels:
    name: ku-pmm-algo-usdt-sa
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: ku-pmm-algo-usdt-config
  namespace: hummingbot
data:
  ku-pmm-algo-usdt.yml: |
    ########################################################
    ###       Pure market making strategy config         ###
    ########################################################
    
    template_version: 24
    strategy: pure_market_making
    
    # Exchange and token parameters.
    exchange: kucoin
    
    # Token trading pair for the exchange, e.g. BTC-USDT
    market: ALGO-USDT
    
    # How far away from mid price to place the bid order.
    # Spread of 1 = 1% away from mid price at that time.
    # Example if mid price is 100 and bid_spread is 1.
    # Your bid is placed at 99.
    bid_spread: 0.6
    
    # How far away from mid price to place the ask order.
    # Spread of 1 = 1% away from mid price at that time.
    # Example if mid price is 100 and ask_spread is 1.
    # Your bid is placed at 101.
    ask_spread: 0.6
    
    # Minimum Spread
    # How far away from the mid price to cancel active orders
    minimum_spread: 0.1
    
    # Time in seconds before cancelling and placing new orders.
    # If the value is 60, the bot cancels active orders and placing new ones after a minute.
    order_refresh_time: 1.0
    
    # Time in seconds before replacing existing order with new orders at the same price.
    max_order_age: 121393.0
    
    # The spread (from mid price) to defer order refresh process to the next cycle.
    # (Enter 1 to indicate 1%), value below 0, e.g. -1, is to disable this feature - not recommended.
    order_refresh_tolerance_pct: 0.6
    
    # Size of your bid and ask order.
    order_amount: 50.0
    
    # Price band ceiling.
    price_ceiling: -1.0
    
    # Price band floor.
    price_floor: -1.0
    
    # enable moving price floor and ceiling.
    moving_price_band_enabled: true
    
    # Price band ceiling pct.
    price_ceiling_pct: 5.0
    
    # Price band floor pct.
    price_floor_pct: -3.0
    
    # price_band_refresh_time.
    price_band_refresh_time: 121393.0
    
    # Whether to alternate between buys and sells (true/false).
    ping_pong_enabled: false
    
    # Whether to enable Inventory skew feature (true/false).
    inventory_skew_enabled: true
    
    # Target base asset inventory percentage target to be maintained (for Inventory skew feature).
    inventory_target_base_pct: 50.0
    
    # The range around the inventory target base percent to maintain, expressed in multiples of total order size (for
    # inventory skew feature).
    inventory_range_multiplier: 1.0
    
    # Initial price of the base asset. Note: this setting is not affects anything, the price is kept in the database.
    inventory_price: 1.0
    
    # Number of levels of orders to place on each side of the order book.
    order_levels: 2
    
    # Increase or decrease size of consecutive orders after the first order (if order_levels > 1).
    order_level_amount: 7.08
    
    # Order price space between orders (if order_levels > 1).
    order_level_spread: 0.1416
    
    # How long to wait before placing the next order in case your order gets filled.
    filled_order_delay: 144.0
    
    # Whether to stop cancellations of orders on the other side (of the order book),
    # when one side is filled (hanging orders feature) (true/false).
    hanging_orders_enabled: true
    
    # Spread (from mid price, in percentage) hanging orders will be canceled (Enter 1 to indicate 1%)
    hanging_orders_cancel_pct: 55.0
    
    # Whether to enable order optimization mode (true/false).
    order_optimization_enabled: true
    
    # The depth in base asset amount to be used for finding top ask (for order optimization mode).
    ask_order_optimization_depth: 0.0
    
    # The depth in base asset amount to be used for finding top bid (for order optimization mode).
    bid_order_optimization_depth: 0.0
    
    # Whether to enable adding transaction costs to order price calculation (true/false).
    add_transaction_costs: false
    
    # The price source (current_market/external_market/custom_api).
    price_source: current_market
    
    # The price type (mid_price/last_price/last_own_trade_price/best_bid/best_ask/inventory_cost).
    price_type: mid_price
    
    # An external exchange name (for external exchange pricing source).
    price_source_exchange:
    
    # A trading pair for the external exchange, e.g. BTC-USDT (for external exchange pricing source).
    price_source_market:
    
    # An external api that returns price (for custom_api pricing source).
    price_source_custom_api:
    
    # An interval time in second to update the price from custom api (for custom_api pricing source).
    custom_api_update_interval: 5.0
    
    #Take order if they cross order book when external price source is enabled
    take_if_crossed:
    
    # Use user provided orders to directly override the orders placed by order_amount and order_level_parameter
    # This is an advanced feature and user is expected to directly edit this field in config file
    # Below is an sample input, the format is a dictionary, the key is user-defined order name, the value is a list which includes buy/sell, order spread, and order amount
    # order_override:
    #   order_1: [buy, 0.5, 100]
    #   order_2: [buy, 0.75, 200]
    #   order_3: [sell, 0.1, 500]
    # Please make sure there is a space between : and [
    order_override:
    
    # Simpler override config for seperate bid and order level spreads
    split_order_levels_enabled: false
    bid_order_level_spreads:
    ask_order_level_spreads:
    bid_order_level_amounts:
    ask_order_level_amounts:
    # If the strategy should wait to receive cancellations confirmation before creating new orders during refresh time
    should_wait_order_cancel_confirmation: true
    
    # For more detailed information, see:
    # https://docs.hummingbot.io/strategies/pure-market-making/#configuration-parameters

  encrypted_default.json: |
    {"crypto": {"cipher": "aes-128-ctr", "cipherparams": {"iv": "d8a5616866c2606c43693018bcafed6f"}, "ciphertext": "2a688380b2526891dfb3df7ae02e52c6d630", "kdf": "pbkdf2", "kdfparams": {"c": 1000000, "dklen": 32, "prf": "hmac-sha256", "salt": "5e1169dac4635bb84c121e22d7c049ef"}, "mac": "d7ee8c928c993738a5b671ce98c7b1b5f0c0ef899bb1b93a95879a3864d70d62"}, "version": 3}
  conf_global.yml: |
    #################################
    ###   Global configurations   ###
    #################################
    
    # For more detailed information: https://docs.hummingbot.io
    template_version: 35
    
    # Exchange configs
    
    kraken_api_tier: Starter
    
    celo_address:
    kill_switch_enabled: false
    # The rate of performance at which you would want the bot to stop trading (-20 = 20%)
    kill_switch_rate: -8.0
    
    # What to auto-fill in the prompt after each import command (start/config)
    autofill_import:
    
    # Paper Trading
    paper_trade_exchanges:
    - binance
    - kucoin
    - ascend_ex
    - gate_io
    paper_trade_account_balance:
      BTC: 1
      USDT: 1000
      ONE: 1000
      USDQ: 1000
      TUSD: 1000
      ETH: 10
      WETH: 10
      USDC: 1000
      DAI: 1000
    
    telegram_enabled: true
    telegram_token: 5125855353:aagbqt5oohm8hgfqwpm2vrwo24b5lqfnyoi
    telegram_chat_id: '1025750362'
    
    # Error log sharing
    send_error_logs: true
    
    # Advanced configs: Do NOT touch unless you understand what you are changing
    instance_id: 40a408a0396c8b682ecab7fa2dfefc9a8d02ab57
    log_level: INFO
    debug_console: false
    strategy_report_interval: 900.0
    logger_override_whitelist:
    - hummingbot.strategy.arbitrage
    - hummingbot.strategy.cross_exchange_market_making
    - conf
    key_file_path: conf/
    log_file_path: logs/
    
    # Advanced database options, currently supports SQLAlchemy's included dialects
    # Reference: https://docs.sqlalchemy.org/en/13/dialects/
    db_engine: postgresql+psycopg2
    db_host: 35.224.47.203
    db_port: '5432'
    db_username: postgres
    db_password: Whitehole1
    db_name: postgres



    pmm_script_enabled: true
    pmm_script_file_path: dynamic_prices.py
    
    # Balance Limit Configurations
    # e.g. Setting USDT and BTC limits on Binance.
    # balance_asset_limit:
    #   binance:
    #     BTC: 0.1
    #     USDT: 1000
    balance_asset_limit:
      binance:
    
    # Fixed gas price (in Gwei) for Ethereum transactions
    manual_gas_price: 50.0
    
    # Gateway API Configurations
    # default host to only use localhost
    # Port need to match the final installation port for Gateway
    gateway_api_host: localhost
    gateway_api_port: '5000'
    
    # Whether to enable aggregated order and trade data collection
    anonymized_metrics_enabled: true
    # The frequency of sending the aggregated order and trade data (in minutes, e.g. enter 5 for once every 5 minutes)
    anonymized_metrics_interval_min: 15.0
    
    # Command Shortcuts
    # Define abbreviations for often used commands
    # or batch grouped commands together
    #
    command_shortcuts:
    - command: spreads
      help: Set bid and ask spread
      arguments: [Bid Spread, Ask Spread]
      output: [config bid_spread $1, config ask_spread $2]
    
    # A source for rate oracle, currently binance or coingecko
    rate_oracle_source: binance
    
    # A universal token which to display tokens values in, e.g. USD,EUR,BTC
    global_token: USD
    
    # A symbol for the global token, e.g. $, â‚¬
    global_token_symbol: $
    
    # Percentage of API rate limits (on any exchange and any end point) allocated to this bot instance.
    # Enter 50 to indicate 50%. E.g. if the API rate limit is 100 calls per second, and you allocate 50% to this setting,
    # the bot will have a maximum (limit) of 50 calls per second
    rate_limits_share_pct: 100.0
    
    # network timeout when fetching minimum order amount in the `create` command
    create_command_timeout: 10.0
    
    # network timeout for other commands (i.e. import, connect, balance, history)
    other_commands_timeout: 30.0
    
    # Background color of the top pane
    top-pane: '#000000'
    
    # Background color of the bottom pane
    bottom-pane: '#000000'
    
    # Background color of the output pane
    output-pane: '#262626'
    
    # Background color of the input pane
    input-pane: '#1C1C1C'
    
    # Background color of the logs pane
    logs-pane: '#121212'
    
    # Terminal primary color
    terminal-primary: '#5FFFD7'
    
    # Primary label color
    primary-label: '#5FFFD7'
    
    # Secondary label color
    secondary-label: '#FFFFFF'
    
    # Success label color
    success-label: '#5FFFD7'
    
    # Warning label color
    warning-label: '#FFFF00'
    
    # Info label color
    info-label: '#5FD7FF'
    
    # Error label color
    error-label: '#FF0000'
    
    # tabulate table format style (https://github.com/astanin/python-tabulate#table-format)
    tables_format: psql

  dynamic_prices.py: |
    #################################
    ###   PMM Script Configuration   ###
    #################################
    
    from decimal import Decimal
    from datetime import datetime
    import time
    from hummingbot.pmm_script.pmm_script_base import PMMScriptBase
    from os.path import realpath, join
    
    s_decimal_1 = Decimal("1")
    LOGS_PATH = realpath(join(__file__, "../../logs/"))
    SCRIPT_LOG_FILE = f"{LOGS_PATH}/logs_script.log"
    
    
    def log_to_file(file_name, message):
        with open(file_name, "a+") as f:
            f.write(datetime.now().strftime("%Y-%m-%d %H:%M:%S") + " - " + message + "\n")
    
    class DynamicPriceBandSpreadScript(PMMScriptBase):
        """
        Demonstrates how to set a band around a mid price moving average, the strategy is to stop buying when the mid price
        reaches the upper bound of the band and to stop selling when the mid price breaches the lower bound.
        """
    
        # Let's set the upper bound of the band to 5% away from the mid price moving average
        band_upper_bound_pct = Decimal("0.05")
        # Let's set the lower bound of the band to 3% away from the mid price moving average
        band_lower_bound_pct = Decimal("0.03")
        # Let's sample mid prices once every 10 seconds
        avg_interval = 10
        # Let's average the last 5 samples
        avg_length = 5
        """
        Demonstrates how to adjust bid and ask spreads based on price volatility.
        The volatility, in this example, is simply a price change compared to the previous cycle regardless of its
        direction, e.g. if price changes -3% (or 3%), the volatility is 3%.
        To update our pure market making spreads, we're gonna smooth out the volatility by averaging it over a short period
        (short_period), and we need a benchmark to compare its value against. In this example the benchmark is a median
        long period price volatility (you can also use a fixed number, e.g. 3% - if you expect this to be the norm for your
        market).
        For example, if our bid_spread and ask_spread are at 0.8%, and the median long term volatility is 1.5%.
        Recently the volatility jumps to 2.6% (on short term average), we're gonna adjust both our bid and ask spreads to
        1.9%  (the original spread - 0.8% plus the volatility delta - 1.1%). Then after a short while the volatility drops
        back to 1.5%, our spreads are now adjusted back to 0.8%.
        """
    
        # Let's set interval and sample sizes as below.
        # These numbers are for testing purposes only (in reality, they should be larger numbers)
        # interval is a interim which to pick historical mid price samples from, if you set it to 5, the first sample is
        # the last (current) mid price, the second sample is a past mid price 5 seconds before the last, and so on.
        interval = 5
        # short_period is how many interval to pick the samples for the average short term volatility calculation,
        # for short_period of 3, this is 3 samples (5 seconds interval), of the last 15 seconds
        short_period = 3
        # long_period is how many interval to pick the samples for the median long term volatility calculation,
        # for long_period of 10, this is 10 samples (5 seconds interval), of the last 50 seconds
        long_period = 13
        last_stats_logged = 0
    
        def __init__(self):
            super().__init__()
            self.original_bid_spread = None
            self.original_ask_spread = None
            self.avg_short_volatility = None
            self.median_long_volatility = None
    
        def volatility_msg(self, include_mid_price=False):
            if self.avg_short_volatility is None or self.median_long_volatility is None:
                return "PriceBands: Active | Short volatility: N/A  Long volatility: N/A"
            mid_price_msg = f"  mid_price: {self.mid_price:<15}" if include_mid_price else ""
            return f"PriceBands: Active | Short volatility: {self.avg_short_volatility:.2%}  " \
                   f"Long volatility:: {self.median_long_volatility:.2%}{mid_price_msg}"
    
        def on_tick(self):
            avg_mid_price = self.avg_mid_price(self.avg_interval, self.avg_length)
            # The avg can be None when the bot just started as there are not enough mid prices to sample values from.
            if avg_mid_price is None:
                return
            upper_bound = avg_mid_price * (s_decimal_1 + self.band_upper_bound_pct)
            lower_bound = avg_mid_price * (s_decimal_1 - self.band_lower_bound_pct)
            # When mid_price reaches the upper bound, we expect the price to bounce back as such we don't want be a buyer
            # (as we can probably buy back at a cheaper price later).
            # If you anticipate the opposite, i.e. the price breaks out on a run away move, you can protect your inventory
            # by stop selling (setting the sell_levels to 0).
            if self.mid_price >= upper_bound:
                self.pmm_parameters.buy_levels = 0
            else:
                self.pmm_parameters.buy_levels = self.pmm_parameters.order_levels
            # When mid_price reaches the lower bound, we don't want to be a seller.
            if self.mid_price <= lower_bound:
                self.pmm_parameters.sell_levels = 0
            else:
                self.pmm_parameters.sell_levels = self.pmm_parameters.order_levels
    
            # First, let's keep the original spreads.
            if self.original_bid_spread is None:
                self.original_bid_spread = self.pmm_parameters.bid_spread
                self.original_ask_spread = self.pmm_parameters.ask_spread
    
            # Average volatility (price change) over a short period of time, this is to detect recent sudden changes.
            self.avg_short_volatility = self.avg_price_volatility(self.interval, self.short_period)
            # Median volatility over a long period of time, this is to find the market norm volatility.
            # We use median (instead of average) to find the middle volatility value - this is to avoid recent
            # spike affecting the average value.
            self.median_long_volatility = self.median_price_volatility(self.interval, self.long_period)
    
            # If the bot just got started, we'll not have these numbers yet as there is not enough mid_price sample size.
            # We'll start to have these numbers after interval * long_term_period.
            if self.avg_short_volatility is None or self.median_long_volatility is None:
                return
    
            # Let's log some stats once every 5 minutes
            if time.time() - self.last_stats_logged > 60 * 5:
                log_to_file(SCRIPT_LOG_FILE, self.volatility_msg(True))
                self.last_stats_logged = time.time()
    
            # This volatility delta will be used to adjust spreads.
            delta = self.avg_short_volatility - self.median_long_volatility
            # Let's round the delta into 0.25% increment to ignore noise and to avoid adjusting the spreads too often.
            spread_adjustment = self.round_by_step(delta, Decimal("0.0025"))
            # Show the user on what's going, you can remove this statement to stop the notification.
            # self.notify(f"avg_short_volatility: {avg_short_volatility} median_long_volatility: {median_long_volatility} "
            #             f"spread_adjustment: {spread_adjustment}")
            new_bid_spread = self.original_bid_spread + spread_adjustment
            # Let's not set the spreads below the originals, this is to avoid having spreads to be too close
            # to the mid price.
            new_bid_spread = max(self.original_bid_spread, new_bid_spread)
            old_bid_spread = self.pmm_parameters.bid_spread
            if new_bid_spread != self.pmm_parameters.bid_spread:
                self.pmm_parameters.bid_spread = new_bid_spread
    
            new_ask_spread = self.original_ask_spread + spread_adjustment
            new_ask_spread = max(self.original_ask_spread, new_ask_spread)
            if new_ask_spread != self.pmm_parameters.ask_spread:
                self.pmm_parameters.ask_spread = new_ask_spread
            if old_bid_spread != new_bid_spread:
                log_to_file(SCRIPT_LOG_FILE, self.volatility_msg(True))
                log_to_file(SCRIPT_LOG_FILE, f"spreads adjustment: Old Value: {old_bid_spread:.2%} "
                                             f"New Value: {new_bid_spread:.2%}")
    
        def on_status(self) -> str:
            return self.volatility_msg()
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: ku-pmm-algo-usdt
  namespace: hummingbot
spec:
  replicas: 1
  serviceName: ku-pmm-algo-usdt
  selector:
    matchLabels:
      app: ku-pmm-algo-usdt-hummingbot
  template:
    metadata:
      labels:
        app: ku-pmm-algo-usdt-hummingbot
    spec:
      serviceAccountName: ku-pmm-algo-usdt-sa
      containers:
        - name: ku-pmm-algo-usdt
          image: bgtcapital/hummingbot_pg:latest
          resources:
            limits:
              cpu: 150m
#              ephemeral-storage: 1Gi
              memory: 512Mi
            requests:
              cpu: 50m
#              ephemeral-storage: 1Gi
              memory: 250Mi


          imagePullPolicy: IfNotPresent
          tty: true
          stdin: true
          command: [ /bin/bash ]
          args:
            - -c
            - >
              cp -r /readonly-conf/. /conf ; cp -r /readonly-conf/dynamic_prices.py /pmm-scripts ; /home/hummingbot/miniconda3/envs/$(head -1 setup/environment-linux.yml | cut -d' ' -f2)/bin/python3
#              cp -r /readonly-conf/. /conf ; /home/hummingbot/miniconda3/envs/$(head -1 setup/environment-linux.yml | cut -d' ' -f2)/bin/python3
              bin/hummingbot_quickstart.py
              -p Whitehole001
              -f ku-pmm-algo-usdt.yml
          volumeMounts:
            - name: config
              mountPath: "/readonly-conf"
      volumes:
        - name: config
          configMap:
            name: ku-pmm-algo-usdt-config
